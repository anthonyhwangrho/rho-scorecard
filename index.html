<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rho Sales Rep Scorecard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', sans-serif;
            background: #F8F9FA;
            padding: 20px;
            min-height: 100vh;
            color: #0A0A0A;
        }

        /* Dark auth background */
        body.auth-mode {
            background: #1A1A1A;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
        }

        body.auth-mode .container {
            max-width: 480px;
            width: 100%;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .card {
            background: #FFFFFF;
            border: 1px solid #E5E7EB;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px -1px rgba(10, 10, 10, 0.08);
        }

        /* Auth card styling for dark mode */
        body.auth-mode .card {
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            border: none;
            padding: 48px 40px;
        }

        h1 {
            color: #0A0A0A;
            margin-bottom: 0;
            font-size: 32px;
            font-weight: 700;
            line-height: 1.2;
        }

        h2 {
            color: #0A0A0A;
            margin-bottom: 20px;
            font-size: 28px;
            font-weight: 700;
            line-height: 1.3;
        }

        h3 {
            font-weight: 600;
            color: #0A0A0A;
        }

        .subtitle {
            color: #777;
            margin-top: 5px;
            margin-bottom: 0;
        }

        .auth-section {
            display: grid;
            gap: 15px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        label {
            color: #555;
            font-weight: 600;
            margin-bottom: 5px;
            font-size: 14px;
        }

        input {
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input:focus {
            outline: none;
            border-color: #00EBC0;
        }

        button {
            background: #00EBC0;
            color: white;
            padding: 14px 28px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
            margin-top: 10px;
        }

        button:hover {
            background: #00BF99;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .login-btn {
            background: #0A0A0A;
            font-size: 18px;
            padding: 16px 32px;
            width: 100%;
        }

        .login-btn:hover {
            background: #2A2A2A;
        }

        /* Rho logo styling */
        .auth-logo {
            text-align: center;
            margin-bottom: 32px;
        }

        .auth-logo svg {
            width: 80px;
            height: auto;
        }

        .auth-title {
            text-align: center;
            margin-bottom: 32px;
        }

        .auth-subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 32px;
            font-size: 15px;
            line-height: 1.6;
        }

        .logout-btn {
            background: #0A0A0A;
            padding: 10px 20px;
            font-size: 14px;
        }

        .logout-btn:hover {
            background: #2A2A2A;
        }

        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .logout-btn-corner {
            background: #0A0A0A;
            color: white;
        }

        .logout-btn-corner:hover {
            background: #2A2A2A;
        }

        .scorecard {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }

        .metric-card {
            background: #FFFFFF;
            border: 1px solid #E5E7EB;
            border-radius: 8px;
            padding: 18px;
            transition: all 0.2s;
            box-shadow: 0 1px 2px 0 rgba(10, 10, 10, 0.05);
        }

        .metric-card:hover {
            border-color: #00EBC0;
            box-shadow: 0 4px 6px -1px rgba(10, 10, 10, 0.08);
            transform: translateY(-2px);
        }

        .metric-card.aggregate {
            grid-column: span 2;
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border: 2px solid #00EBC0;
            padding: 12px 20px;
        }

        .aggregate .metric-header {
            margin-bottom: 8px;
        }

        .aggregate .metric-name {
            font-size: 24px;
        }

        .aggregate .gauge-percentage {
            font-size: 56px;
        }

        .aggregate-gauge {
            margin: 32px 0 8px 0;
        }

        .aggregate-gauge .gauge-svg {
            max-width: 300px;
            width: 100%;
        }

        .aggregate .metric-values {
            margin-top: 0;
        }

        .metric-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .metric-name {
            font-size: 18px;
            font-weight: 700;
            color: #333;
            line-height: 1.4;
        }

        .metric-status {
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-success {
            background: #10b981;
            color: white;
        }

        .status-warning {
            background: #f59e0b;
            color: white;
        }

        .status-danger {
            background: #ef4444;
            color: white;
        }

        .metric-values {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .value-item {
            display: flex;
            flex-direction: column;
        }

        .value-label {
            color: #666;
            font-size: 12px;
            margin-bottom: 3px;
        }

        .value-number {
            font-size: 24px;
            font-weight: 700;
            color: #333;
        }

        .progress-bar-container {
            background: #e0e0e0;
            border-radius: 10px;
            height: 20px;
            overflow: hidden;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            border-radius: 10px;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 10px;
            color: white;
            font-size: 12px;
            font-weight: 600;
        }

        .progress-success {
            background: linear-gradient(90deg, #10b981 0%, #059669 100%);
        }

        .progress-warning {
            background: linear-gradient(90deg, #F59E0B 0%, #D97706 100%);
        }

        .progress-danger {
            background: linear-gradient(90deg, #EF4444 0%, #DC2626 100%);
        }

        .hidden {
            display: none;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #667eea;
            font-size: 18px;
        }

        .error {
            background: #fee2e2;
            color: #991b1b;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid #dc2626;
            text-align: center;
        }

        .success {
            background: #d1fae5;
            color: #065f46;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid #10b981;
            text-align: center;
        }

        .info-box {
            background: #dbeafe;
            border-left: 4px solid #3b82f6;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            color: #1e40af;
            font-size: 14px;
            line-height: 1.6;
        }

        .info-box strong {
            display: block;
            margin-bottom: 8px;
            font-size: 15px;
        }

        .info-box ol, .info-box ul {
            margin-left: 20px;
            margin-top: 10px;
        }

        .info-box li {
            margin-bottom: 5px;
        }

        .info-box code {
            background: #1e40af;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 13px;
        }

        .refresh-btn {
            background: #00EBC0;
            margin-right: 10px;
        }

        .refresh-btn:hover {
            background: #00BF99;
        }

        .config-btn {
            background: #0A0A0A;
        }

        .config-btn:hover {
            background: #2A2A2A;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        .user-info {
            background: #0A0A0A;
            padding: 16px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .user-info-text {
            color: #FFFFFF;
            font-size: 14px;
            line-height: 1.5;
        }

        .user-info-text strong {
            font-weight: 600;
            margin-right: 8px;
        }

        .modal {
            display: flex;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 30px;
            border-bottom: 1px solid #e0e0e0;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 22px;
        }

        .close-btn {
            font-size: 32px;
            color: #999;
            cursor: pointer;
            line-height: 1;
        }

        .close-btn:hover {
            color: #333;
        }

        .modal-body {
            padding: 30px;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding: 20px 30px;
            border-top: 1px solid #e0e0e0;
        }

        .target-input-group {
            margin-bottom: 20px;
        }

        .target-input-group label {
            display: block;
            color: #555;
            font-weight: 600;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .target-input-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
        }

        .target-input-group input:focus {
            outline: none;
            border-color: #00EBC0;
        }

        .input-with-unit {
            display: flex;
            align-items: center;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            overflow: hidden;
        }

        .input-with-unit:focus-within {
            border-color: #00EBC0;
        }

        .input-with-unit input {
            border: none;
            border-radius: 0;
            flex: 1;
        }

        .input-with-unit input:focus {
            border: none;
            outline: none;
        }

        .input-unit {
            padding: 12px;
            background: #f5f5f5;
            color: #555;
            font-weight: 600;
            font-size: 14px;
        }

        .input-unit-prefix {
            border-right: 1px solid #e0e0e0;
        }

        .input-unit-suffix {
            border-left: 1px solid #e0e0e0;
        }

        a {
            color: #00EBC0;
            text-decoration: none;
        }

        a:hover {
            color: #00BF99;
            text-decoration: underline;
        }

        input:focus, select:focus {
            box-shadow: 0 0 0 3px rgba(0, 235, 192, 0.1);
        }

        .gauge-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 32px 0 8px 0;
            position: relative;
        }

        .gauge-svg {
            max-width: 200px;
            height: auto;
        }

        .gauge-value {
            position: absolute;
            font-size: 32px;
            font-weight: 700;
            color: #0A0A0A;
        }

        .gauge-label {
            position: absolute;
            bottom: 30px;
            font-size: 12px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }

        .insights-card {
            background: #1A1A1A;
            border: 1px solid #00EBC0;
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 20px;
            color: #FFFFFF;
        }

        .insights-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 16px;
        }

        .insights-icon {
            font-size: 24px;
        }

        .insights-title {
            font-size: 18px;
            font-weight: 600;
            color: #00EBC0;
        }

        .insights-summary {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid #333;
            color: #FFFFFF;
        }

        .insights-recommendations {
            margin-top: 12px;
        }

        .insights-recommendations h4 {
            font-size: 18px;
            font-weight: 600;
            color: #00EBC0;
            margin-bottom: 16px;
        }

        .recommendation-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            margin-bottom: 12px;
            padding: 0;
        }

        .recommendation-icon {
            color: #00EBC0;
            font-weight: 700;
            flex-shrink: 0;
        }

        .recommendation-text {
            font-size: 16px;
            line-height: 1.6;
            color: #E0E0E0;
        }

        .view-toggle-group {
            display: flex;
            gap: 10px;
            background: #F8F9FA;
            padding: 4px;
            border-radius: 8px;
            width: fit-content;
        }

        .view-toggle-btn {
            background: transparent;
            color: #666;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin: 0;
        }

        .view-toggle-btn:hover {
            background: #E5E7EB;
            transform: none;
        }

        .view-toggle-btn.active {
            background: #00EBC0;
            color: white;
        }

        .pace-info {
            margin-top: 12px;
            padding: 12px;
            background: #F8F9FA;
            border-left: 3px solid #00EBC0;
            border-radius: 4px;
            font-size: 13px;
            color: #666;
        }

        /* GP Attainment Table Styles */
        .gp-attainment-card {
            background: #FFFFFF;
            border: 1px solid #E5E7EB;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px -1px rgba(10, 10, 10, 0.08);
        }

        .gp-attainment-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
        }

        .gp-attainment-icon {
            font-size: 24px;
        }

        .gp-attainment-title {
            font-size: 24px;
            font-weight: 700;
            color: #0A0A0A;
        }

        .gp-attainment-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 16px;
            table-layout: fixed;
        }

        .gp-attainment-table th,
        .gp-attainment-table td {
            padding: 12px 16px;
        }

        .gp-attainment-table th:nth-child(1),
        .gp-attainment-table td:nth-child(1) { width: 17.5%; }

        .gp-attainment-table th:nth-child(n+2),
        .gp-attainment-table td:nth-child(n+2) { width: 13.75%; }

        .gp-attainment-table th {
            text-align: left;
            background: #F8F9FA;
            border-bottom: 2px solid #E5E7EB;
            font-weight: 600;
            color: #555;
        }

        .gp-attainment-table th:not(:first-child) {
            text-align: right;
        }

        .gp-attainment-table td {
            border-bottom: 1px solid #E5E7EB;
        }

        .gp-attainment-table td:not(:first-child) {
            text-align: right;
        }

        .gp-attainment-table tr:hover {
            background: #F8F9FA;
        }

        .gp-attainment-table .rep-name {
            font-weight: 500;
            color: #0A0A0A;
        }

        .gp-attainment-table .currency {
            color: #0A0A0A;
        }

        .gp-attainment-table .percent-good {
            color: #10B981;
            font-weight: 600;
        }

        .gp-attainment-table .percent-warning {
            color: #F59E0B;
            font-weight: 600;
        }

        .gp-attainment-table .percent-danger {
            color: #EF4444;
            font-weight: 600;
        }

        .gp-attainment-loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        @media (max-width: 768px) {
            .scorecard {
                grid-template-columns: 1fr;
            }

            .metric-values {
                flex-direction: column;
                gap: 10px;
            }

            .modal-content {
                width: 95%;
                max-height: 90vh;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="authCard" class="card">
            <div id="authCardHeader">
                <h1>Rho Sales Rep Scorecard</h1>
                <p class="subtitle">Track your metrics against targets in real-time</p>
            </div>

            <div id="setupSection" class="hidden">
                <div class="auth-logo">
                    <svg viewBox="0 0 120 40" xmlns="http://www.w3.org/2000/svg">
                        <text x="60" y="30" font-family="Arial, sans-serif" font-size="32" font-weight="700" text-anchor="middle" fill="#0A0A0A">Rho</text>
                    </svg>
                </div>
                <div class="auth-title">
                    <h2 style="margin: 0; font-size: 24px;">Setup Configuration</h2>
                </div>

                <div class="info-box">
                    <strong>First Time Setup - Create a Connected App in Salesforce:</strong>
                    <ol>
                        <li>Log into Salesforce â†’ Setup â†’ App Manager â†’ New Connected App</li>
                        <li>Fill in: Connected App Name, API Name, Contact Email</li>
                        <li>Enable OAuth Settings âœ“</li>
                        <li>Set Callback URL to: <code id="callbackUrlDisplay"></code></li>
                        <li>Selected OAuth Scopes: Add <code>Full access (full)</code> and <code>Perform requests at any time (refresh_token, offline_access)</code></li>
                        <li>Click Save, then Continue</li>
                        <li>Click "Manage Consumer Details" to get your Consumer Key</li>
                        <li>Copy the Consumer Key and paste it below</li>
                    </ol>
                </div>

                <div class="form-group">
                    <label for="clientId">Consumer Key (Client ID)</label>
                    <input type="text" id="clientId" placeholder="Paste your Connected App Consumer Key here">
                </div>

                <div class="form-group">
                    <label for="instanceUrl">Salesforce Login URL</label>
                    <input type="text" id="instanceUrl" placeholder="https://login.salesforce.com or https://test.salesforce.com" value="https://login.salesforce.com">
                    <small style="color: #666; margin-top: 5px;">Use https://test.salesforce.com for sandbox</small>
                </div>

                <button onclick="saveConfig()" style="width: 100%;">Save Configuration</button>
            </div>

            <div id="loginSection" class="hidden">
                <div class="auth-logo">
                    <svg viewBox="0 0 120 40" xmlns="http://www.w3.org/2000/svg">
                        <text x="60" y="30" font-family="Arial, sans-serif" font-size="32" font-weight="700" text-anchor="middle" fill="#0A0A0A">Rho</text>
                    </svg>
                </div>
                <div class="auth-title">
                    <h2 style="margin: 0; font-size: 24px;">Sales Rep Scorecard</h2>
                </div>
                <div class="auth-subtitle">
                    Connect to Salesforce to view your performance metrics and track your progress in real-time.
                </div>
                <button class="login-btn" onclick="loginWithSalesforce()">Sign in with Salesforce</button>
            </div>

            <div id="errorMessage" class="error hidden"></div>
            <div id="successMessage" class="success hidden"></div>
        </div>

        <div id="scorecardSection" class="hidden">
            <div class="card">
                <div class="header-container">
                    <div>
                        <h1>Rho Sales Rep Scorecard</h1>
                        <p class="subtitle">Track your metrics against targets in real-time</p>
                    </div>
                    <div id="userInfoSection" class="hidden">
                        <button class="logout-btn-corner" onclick="logout()">Logout</button>
                    </div>
                </div>

                <div style="margin-bottom: 20px;">
                    <label for="ownerSelect" style="display: block; margin-bottom: 8px; color: #555; font-weight: 600;">Filter By Sales Rep:</label>
                    <select id="ownerSelect" onchange="loadScorecard()" style="padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px; width: 100%; max-width: 300px; cursor: pointer;">
                        <option value="">Loading owners...</option>
                    </select>
                </div>

                <!-- GP Attainment Section -->
                <div id="gpAttainmentSection" class="gp-attainment-card hidden">
                    <div class="gp-attainment-header">
                        <div>
                            <h3 class="gp-attainment-title">Quarterly GP Attainment</h3>
                            <a id="gpAttainmentReportLink" href="https://rho.lightning.force.com/00OTP0000028AU52AM" target="_blank" style="font-size: 14px; color: #00EBC0; text-decoration: none;">View Report</a>
                        </div>
                        <button class="config-btn" onclick="showAcceleratorSettings()" style="margin-left: auto;">Edit Accelerators</button>
                    </div>
                    <div id="gpAttainmentContent">
                        <div class="gp-attainment-loading">Loading GP Attainment data...</div>
                    </div>
                </div>

                <!-- AI Insights Section -->
                <div id="insightsSection" class="insights-card hidden">
                    <div class="insights-header">
                        <h3 class="insights-title">Performance Insights</h3>
                    </div>
                    <div id="insightsSummary" class="insights-summary"></div>
                    <div id="insightsRecommendations" class="insights-recommendations"></div>
                </div>

                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2>Performance Metrics</h2>
                    <div class="button-group">
                        <button class="refresh-btn" onclick="loadScorecard()">Refresh</button>
                        <button class="config-btn" onclick="showEditTargets()">Edit Targets</button>
                    </div>
                </div>
                <div id="scorecard" class="scorecard"></div>
            </div>
        </div>

        <div id="editTargetsSection" class="hidden">
            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2>Edit Targets</h2>
                    <button class="config-btn" onclick="showScorecard()">Back to Scorecard</button>
                </div>
                <div id="targetInputs" style="max-width: 500px;"></div>
                <div style="margin-top: 30px;">
                    <button class="refresh-btn" onclick="saveTargets()" style="padding: 14px 32px; font-size: 16px;">Save Targets</button>
                </div>
            </div>
        </div>

        <div id="editAcceleratorSection" class="hidden">
            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2>Edit Accelerators</h2>
                    <button class="config-btn" onclick="showScorecard()">Back to Scorecard</button>
                </div>

                <!-- Payout Percentage Section -->
                <div style="margin-bottom: 40px;">
                    <h3 style="font-size: 18px; font-weight: 600; color: #0A0A0A; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 2px solid #e0e0e0;">Payout Percentage</h3>
                    <div id="payoutInputs" style="max-width: 500px;">
                        <div class="form-group" style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Accelerator Floor (%)</label>
                            <input type="number" id="accelFloor" style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 16px;" min="0" max="200" step="1">
                            <small style="display: block; margin-top: 4px; color: #666;">% To Quota threshold where accelerator kicks in</small>
                        </div>
                        <div class="form-group" style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Multiplier</label>
                            <input type="number" id="accelMultiplier" style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 16px;" min="1" max="5" step="0.05">
                            <small style="display: block; margin-top: 4px; color: #666;">Multiplier applied to amounts above floor (e.g., 1.25 = 125%)</small>
                        </div>
                        <div class="form-group" style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Minimum Payout Threshold (%)</label>
                            <input type="number" id="accelMinimum" style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 16px;" min="0" max="100" step="1">
                            <small style="display: block; margin-top: 4px; color: #666;">Below this % To Quota, payout is 0%</small>
                        </div>
                    </div>
                </div>

                <!-- Large Logo Multiplier Section -->
                <div style="margin-bottom: 30px;">
                    <h3 style="font-size: 18px; font-weight: 600; color: #0A0A0A; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 2px solid #e0e0e0;">Large Logo Multiplier</h3>
                    <div id="logoBandsInputs" style="max-width: 600px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                            <label style="font-weight: 600; color: #333;">Min Logos</label>
                            <label style="font-weight: 600; color: #333;">Max Logos</label>
                            <label style="font-weight: 600; color: #333;">Multiplier</label>
                        </div>
                        <div id="logoBandRows"></div>
                    </div>
                </div>

                <div style="margin-top: 30px;">
                    <button class="refresh-btn" onclick="saveAcceleratorSettingsAndReturn()" style="padding: 14px 32px; font-size: 16px;">Save Settings</button>
                </div>
            </div>
        </div>

        <div id="loading" class="loading hidden">
            <div>Loading metrics...</div>
        </div>
    </div>

    <script>
        // ==========================================
        // CONFIGURATION SECTION
        // ==========================================

        /**
         * Metric Configurations
         *
         * This array contains both report-based and calculated metrics.
         *
         * REPORT-BASED METRICS:
         * - Pull data directly from Salesforce reports
         * - Required fields: type, metricId, reportId, metricName, target, unit, aggregationField, aggregationType
         *
         * CALCULATED METRICS:
         * - Derive values from other metrics using formulas
         * - Required fields: type, metricId, metricName, formula, target, unit
         * - Formula operations: 'divide', 'multiply', 'add', 'subtract'
         *
         * Examples:
         * - Win Rate = (Activations Ã· New Leads) Ã— 100
         * - Application Rate = (Applications Ã· New Leads) Ã— 100
         * - Activation Rate = (Activations Ã· Applications) Ã— 100
         */
        const metricConfigs = [
            // Report-based metrics
            {
                type: 'report',
                metricId: 'newLeads',
                reportId: '00OTP000008LLJO2A4',
                metricName: 'New Leads Created - This Month',
                target: 29,
                unit: '',
                aggregationField: 'ID',
                aggregationType: 'count'
            },
            {
                type: 'report',
                metricId: 'applications',
                reportId: '00OTP000008Vesb2AC',
                metricName: 'Applications Submitted - This Month',
                target: 17,
                unit: '',
                aggregationField: 'ID',
                aggregationType: 'count'
            },
            {
                type: 'report',
                metricId: 'activations',
                reportId: '00OTP000008Vfwk2AC',
                metricName: 'Activations - This Month',
                target: 13,
                unit: '',
                aggregationField: 'ID',
                aggregationType: 'count'
            },
            {
                type: 'report',
                metricId: 'sqlActivatedPercent',
                reportId: '00OTP000002j7iX2AQ',
                metricName: 'SQL To Activated % - Last Six Months',
                target: 45,
                unit: '%',
                aggregationField: 'Conversion %',
                aggregationType: 'formula',
                includeDetails: false
            },
            {
                type: 'report',
                metricId: 'checkingPercentDeposits',
                reportId: '00OTP000008ugj72AA',
                metricName: 'Checking % of Total Deposits - Activated Last Six Months',
                target: 30,
                unit: '%',
                aggregationField: 'Checking %',
                aggregationType: 'formula',
                includeDetails: false
            },
            {
                type: 'report',
                metricId: 'avgTotalBalanceVCICP',
                reportId: '00OTP000008orXZ2AY',
                metricName: 'Avg. Total Balance (VC ICP) - Activated Last Six Months',
                target: 750000,
                unit: '$',
                aggregationField: 'Avg. Total Balance',
                aggregationType: 'formula_currency'
            },
            {
                type: 'report',
                metricId: 'currentDepositsWon',
                reportId: '00OTP0000029F0H2AU',
                metricName: 'Current Deposits Won - This Month',
                target: 10000000,
                unit: '$',
                aggregationField: 'Current Deposits Won',
                aggregationType: 'formula_currency'
            }
        ];

        // Get metric configs with targets from localStorage or defaults
        function getMetricConfigs() {
            const savedTargets = localStorage.getItem('metric_targets');

            if (savedTargets) {
                try {
                    const targets = JSON.parse(savedTargets);
                    // Merge saved targets with default configs
                    return metricConfigs.map(config => ({
                        ...config,
                        target: targets[config.metricId] !== undefined ? targets[config.metricId] : config.target
                    }));
                } catch (e) {
                    console.error('Error loading saved targets:', e);
                }
            }

            return metricConfigs;
        }

        // Save targets to localStorage
        function saveTargetsToStorage(targets) {
            localStorage.setItem('metric_targets', JSON.stringify(targets));
        }

        // ==========================================
        // FORMULA ENGINE
        // ==========================================

        /**
         * Validates metric configurations for errors
         * Checks for missing metricId, duplicates, and invalid formulas
         */
        function validateConfigs(configs) {
            const seenIds = new Set();
            const errors = [];

            configs.forEach((config, index) => {
                // Check for missing metricId
                if (!config.metricId) {
                    errors.push(`Config at index ${index} missing metricId`);
                } else if (seenIds.has(config.metricId)) {
                    errors.push(`Duplicate metricId: ${config.metricId}`);
                }
                seenIds.add(config.metricId);

                // Validate calculated metrics have formulas
                if (config.type === 'calculated') {
                    if (!config.formula || !config.formula.operation) {
                        errors.push(`Calculated metric ${config.metricId} missing formula or operation`);
                    }
                }

                // Validate report-based metrics have reportId
                if (config.type === 'report') {
                    if (!config.reportId) {
                        errors.push(`Report metric ${config.metricId} missing reportId`);
                    }
                }
            });

            if (errors.length > 0) {
                console.error('Configuration errors:', errors);
                showError('Configuration errors detected. Check console for details.');
                return false;
            }

            return true;
        }

        /**
         * Executes a formula using the provided metric values
         * @param {Object} formula - Formula object with operation type and operands
         * @param {Object} metricValues - Map of metricId to actual values
         * @returns {number} Calculated result
         */
        function executeFormula(formula, metricValues) {
            const { operation } = formula;

            switch (operation) {
                case 'divide': {
                    const num = metricValues[formula.numerator];
                    const den = metricValues[formula.denominator];

                    // Validation
                    if (num === undefined) {
                        throw new Error(`Missing metric: ${formula.numerator}`);
                    }
                    if (den === undefined) {
                        throw new Error(`Missing metric: ${formula.denominator}`);
                    }
                    if (typeof num === 'object' && num.error) {
                        throw new Error(`Dependency error in ${formula.numerator}: ${num.error}`);
                    }
                    if (typeof den === 'object' && den.error) {
                        throw new Error(`Dependency error in ${formula.denominator}: ${den.error}`);
                    }

                    // Division by zero handling
                    if (den === 0) {
                        console.log(`Division by zero in formula: ${formula.numerator} / ${formula.denominator}, returning 0`);
                        return 0;
                    }

                    let result = num / den;
                    if (formula.multiplyBy) {
                        result *= formula.multiplyBy;
                    }

                    console.log(`Formula result: ${num} / ${den}${formula.multiplyBy ? ' * ' + formula.multiplyBy : ''} = ${result}`);
                    return result;
                }

                case 'multiply': {
                    const factor1 = metricValues[formula.factor1];
                    const factor2 = metricValues[formula.factor2];

                    if (factor1 === undefined) throw new Error(`Missing metric: ${formula.factor1}`);
                    if (factor2 === undefined) throw new Error(`Missing metric: ${formula.factor2}`);

                    return factor1 * factor2;
                }

                case 'add': {
                    if (!formula.operands || !Array.isArray(formula.operands)) {
                        throw new Error('Add operation requires operands array');
                    }

                    let sum = 0;
                    for (const operandId of formula.operands) {
                        const value = metricValues[operandId];
                        if (value === undefined) throw new Error(`Missing metric: ${operandId}`);
                        sum += value;
                    }
                    return sum;
                }

                case 'subtract': {
                    const minuend = metricValues[formula.minuend];
                    const subtrahend = metricValues[formula.subtrahend];

                    if (minuend === undefined) throw new Error(`Missing metric: ${formula.minuend}`);
                    if (subtrahend === undefined) throw new Error(`Missing metric: ${formula.subtrahend}`);

                    return minuend - subtrahend;
                }

                default:
                    throw new Error(`Unknown operation: ${operation}`);
            }
        }

        /**
         * Calculates derived metrics using formulas
         * @param {Object} metricValues - Map of metricId to values from reports
         * @param {Array} calculatedConfigs - Array of calculated metric configs
         * @returns {Object} Map of calculated metricId to values
         */
        function calculateDerivedMetrics(metricValues, calculatedConfigs) {
            const results = {};

            for (const config of calculatedConfigs) {
                try {
                    console.log(`Calculating ${config.metricName} (${config.metricId})`);
                    const value = executeFormula(config.formula, metricValues);
                    results[config.metricId] = value;
                } catch (error) {
                    console.error(`Error calculating ${config.metricName}:`, error);
                    results[config.metricId] = { error: error.message };
                }
            }

            return results;
        }

        /**
         * Migrates old report_targets localStorage to new metric_targets format
         * Called on app initialization
         */
        function migrateTargetsStorage() {
            const oldTargets = localStorage.getItem('report_targets');
            const newTargets = localStorage.getItem('metric_targets');

            // Only migrate if old exists and new doesn't
            if (oldTargets && !newTargets) {
                try {
                    const oldData = JSON.parse(oldTargets);
                    const newData = {};

                    // Map old reportId keys to new metricId keys
                    metricConfigs.forEach(config => {
                        if (config.type === 'report' && oldData[config.reportId] !== undefined) {
                            newData[config.metricId] = oldData[config.reportId];
                        }
                    });

                    localStorage.setItem('metric_targets', JSON.stringify(newData));
                    console.log('Migrated targets from report_targets to metric_targets:', newData);
                } catch (e) {
                    console.error('Error migrating targets:', e);
                }
            }
        }

        // Performance thresholds
        const thresholds = {
            success: 0.9,  // 90% or above of target
            warning: 0.7   // 70-89% of target
        };

        // ==========================================
        // OAUTH CONFIGURATION
        // ==========================================

        // Pre-configured settings for one-click login
        // These are safe to hardcode (Consumer Key is public, not a secret)
        const PRECONFIGURED = {
            CLIENT_ID: '3MVG9_XwsqeYoueJz1.VgYcbyC6hQlE9I8DJwaiwPCHM0rJIKMG8_PhoTzSw_YEk.2MBHfnIStQRxta_rD6pi',
            LOGIN_URL: 'http://rho.lightning.force.com/'
        };

        // View mode state (default to period pace adjusted)
        let currentViewMode = 'standard';  // 'standard' or 'pace'

        /**
         * Sets the active view mode and refreshes the scorecard
         * @param {string} mode - 'standard' or 'pace'
         */
        function setViewMode(mode) {
            currentViewMode = mode;

            // Update button states
            document.getElementById('standardViewBtn').classList.toggle('active', mode === 'standard');
            document.getElementById('paceViewBtn').classList.toggle('active', mode === 'pace');

            // Show/hide pace info
            const paceInfoDiv = document.getElementById('paceInfo');
            if (mode === 'pace') {
                const monthProgress = getMonthProgress();
                paceInfoDiv.innerHTML = `
                    ðŸ“… Day ${monthProgress.dayOfMonth} of ${monthProgress.totalDays}
                    (${(monthProgress.percentElapsed * 100).toFixed(0)}% of month elapsed)
                `;
                paceInfoDiv.classList.remove('hidden');
            } else {
                paceInfoDiv.classList.add('hidden');
            }

            // Reload scorecard with new view mode
            loadScorecard();
        }

        const STORAGE_KEYS = {
            ACCESS_TOKEN: 'sf_access_token',
            INSTANCE_URL: 'sf_instance_url',
            CLIENT_ID: 'sf_client_id',
            LOGIN_URL: 'sf_login_url',
            USER_INFO: 'sf_user_info',
            ACCELERATOR_SETTINGS: 'accelerator_settings'
        };

        // ==========================================
        // ACCELERATOR SETTINGS
        // ==========================================
        const DEFAULT_ACCELERATOR_SETTINGS = {
            // Payout Percentage settings
            floor: 120,           // Accelerator floor (%)
            multiplier: 1.25,     // Multiplier for amounts above floor
            minimum: 50,          // Minimum % to quota for any payout
            // Large Logo Multiplier bands
            logoBands: [
                { min: 0, max: 7, multiplier: 0.5 },
                { min: 8, max: 11, multiplier: 0.85 },
                { min: 12, max: 18, multiplier: 1.0 },
                { min: 19, max: 999, multiplier: 1.1 }
            ]
        };

        function getAcceleratorSettings() {
            const saved = localStorage.getItem(STORAGE_KEYS.ACCELERATOR_SETTINGS);
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    return {
                        ...DEFAULT_ACCELERATOR_SETTINGS,
                        ...parsed,
                        logoBands: parsed.logoBands || DEFAULT_ACCELERATOR_SETTINGS.logoBands
                    };
                } catch (e) {
                    console.error('Error loading accelerator settings:', e);
                }
            }
            return { ...DEFAULT_ACCELERATOR_SETTINGS };
        }

        function saveAcceleratorSettings(settings) {
            localStorage.setItem(STORAGE_KEYS.ACCELERATOR_SETTINGS, JSON.stringify(settings));
        }

        function calculatePayout(percentToQuota) {
            const settings = getAcceleratorSettings();
            const { floor, multiplier, minimum } = settings;

            // Below minimum: no payout
            if (percentToQuota < minimum) {
                return 0;
            }

            // Between minimum and floor: linear payout
            if (percentToQuota < floor) {
                return percentToQuota;
            }

            // Above floor: accelerated payout
            const baseAmount = floor;
            const excessAmount = percentToQuota - floor;
            const acceleratedExcess = excessAmount * multiplier;
            return baseAmount + acceleratedExcess;
        }

        function calculateLargeLogoMultiplier(largeLogos) {
            const settings = getAcceleratorSettings();
            const { logoBands } = settings;

            for (const band of logoBands) {
                if (largeLogos >= band.min && largeLogos <= band.max) {
                    return band.multiplier;
                }
            }
            // Default to last band if above all
            return logoBands[logoBands.length - 1].multiplier;
        }

        function showAcceleratorSettings() {
            const settings = getAcceleratorSettings();

            // Populate the payout fields
            document.getElementById('accelFloor').value = settings.floor;
            document.getElementById('accelMultiplier').value = settings.multiplier;
            document.getElementById('accelMinimum').value = settings.minimum;

            // Populate the logo bands
            const logoBandRows = document.getElementById('logoBandRows');
            logoBandRows.innerHTML = settings.logoBands.map((band, index) => `
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                    <input type="number" id="bandMin${index}" value="${band.min}" style="padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px;" min="0">
                    <input type="number" id="bandMax${index}" value="${band.max}" style="padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px;" min="0">
                    <input type="number" id="bandMult${index}" value="${band.multiplier}" step="0.05" style="padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px;" min="0">
                </div>
            `).join('');

            // Show accelerator section, hide others
            document.getElementById('scorecardSection').classList.add('hidden');
            document.getElementById('editTargetsSection').classList.add('hidden');
            document.getElementById('editAcceleratorSection').classList.remove('hidden');
        }

        function saveAcceleratorSettingsAndReturn() {
            const currentSettings = getAcceleratorSettings();

            // Collect logo bands from inputs
            const logoBands = [];
            for (let i = 0; i < currentSettings.logoBands.length; i++) {
                const minEl = document.getElementById(`bandMin${i}`);
                const maxEl = document.getElementById(`bandMax${i}`);
                const multEl = document.getElementById(`bandMult${i}`);
                if (minEl && maxEl && multEl) {
                    logoBands.push({
                        min: parseInt(minEl.value) || 0,
                        max: parseInt(maxEl.value) || 999,
                        multiplier: parseFloat(multEl.value) || 1.0
                    });
                }
            }

            const settings = {
                floor: parseFloat(document.getElementById('accelFloor').value) || 120,
                multiplier: parseFloat(document.getElementById('accelMultiplier').value) || 1.25,
                minimum: parseFloat(document.getElementById('accelMinimum').value) || 50,
                logoBands: logoBands.length > 0 ? logoBands : currentSettings.logoBands
            };
            saveAcceleratorSettings(settings);
            showScorecard();
            loadGPAttainmentTable(); // Refresh the table
        }

        // Get the current page URL for the callback
        const redirectUri = window.location.href.split('#')[0].split('?')[0];

        // ==========================================
        // INITIALIZATION
        // ==========================================
        window.addEventListener('DOMContentLoaded', () => {
            document.getElementById('callbackUrlDisplay').textContent = redirectUri;

            // Migrate old localStorage format if needed
            migrateTargetsStorage();

            // Validate metric configurations
            validateConfigs(metricConfigs);

            // Check if we're coming back from OAuth callback
            if (window.location.hash) {
                handleOAuthCallback();
            } else {
                checkAuthStatus();
            }
        });

        function checkAuthStatus() {
            const accessToken = localStorage.getItem(STORAGE_KEYS.ACCESS_TOKEN);
            let clientId = localStorage.getItem(STORAGE_KEYS.CLIENT_ID);
            let loginUrl = localStorage.getItem(STORAGE_KEYS.LOGIN_URL);

            // Auto-configure with pre-set values if not already configured
            if (!clientId) {
                clientId = PRECONFIGURED.CLIENT_ID;
                localStorage.setItem(STORAGE_KEYS.CLIENT_ID, clientId);
            }
            if (!loginUrl) {
                loginUrl = PRECONFIGURED.LOGIN_URL;
                localStorage.setItem(STORAGE_KEYS.LOGIN_URL, loginUrl);
            }

            if (accessToken) {
                // Already authenticated
                showUserInfo();
                // Note: loadScorecard() is called by loadOpportunityOwners() after auto-selecting first owner
            } else {
                // Show login button (skip setup entirely)
                showLoginSection();
            }
        }

        function showSetup() {
            // Enable auth mode styling
            document.body.classList.add('auth-mode');

            document.getElementById('authCard').classList.remove('hidden');
            document.getElementById('authCardHeader').classList.add('hidden');
            document.getElementById('setupSection').classList.remove('hidden');
            document.getElementById('loginSection').classList.add('hidden');
            document.getElementById('userInfoSection').classList.add('hidden');
            document.getElementById('scorecardSection').classList.add('hidden');

            // Pre-fill if exists
            const clientId = localStorage.getItem(STORAGE_KEYS.CLIENT_ID);
            const loginUrl = localStorage.getItem(STORAGE_KEYS.LOGIN_URL);
            if (clientId) document.getElementById('clientId').value = clientId;
            if (loginUrl) document.getElementById('instanceUrl').value = loginUrl;
        }

        function showLoginSection() {
            // Enable auth mode styling
            document.body.classList.add('auth-mode');

            document.getElementById('authCard').classList.remove('hidden');
            document.getElementById('authCardHeader').classList.add('hidden');
            document.getElementById('setupSection').classList.add('hidden');
            document.getElementById('loginSection').classList.remove('hidden');
            document.getElementById('userInfoSection').classList.add('hidden');
            document.getElementById('scorecardSection').classList.add('hidden');
        }

        function showUserInfo() {
            // Disable auth mode styling
            document.body.classList.remove('auth-mode');

            document.getElementById('authCard').classList.add('hidden');
            document.getElementById('authCardHeader').classList.remove('hidden');
            document.getElementById('setupSection').classList.add('hidden');
            document.getElementById('loginSection').classList.add('hidden');
            document.getElementById('userInfoSection').classList.remove('hidden');
            document.getElementById('scorecardSection').classList.remove('hidden');

            // Load opportunity owners for the dropdown
            loadOpportunityOwners();
        }

        // ==========================================
        // OAUTH FLOW
        // ==========================================
        function saveConfig() {
            const clientId = document.getElementById('clientId').value.trim();
            const loginUrl = document.getElementById('instanceUrl').value.trim();

            if (!clientId) {
                showError('Please enter your Consumer Key');
                return;
            }

            if (!loginUrl) {
                showError('Please enter your Salesforce login URL');
                return;
            }

            localStorage.setItem(STORAGE_KEYS.CLIENT_ID, clientId);
            localStorage.setItem(STORAGE_KEYS.LOGIN_URL, loginUrl);

            showSuccess('Configuration saved! Click "Login with Salesforce" to connect.');
            showLoginSection();
        }

        function loginWithSalesforce() {
            const clientId = localStorage.getItem(STORAGE_KEYS.CLIENT_ID);
            const loginUrl = localStorage.getItem(STORAGE_KEYS.LOGIN_URL);

            if (!clientId) {
                showError('Please configure your Consumer Key first');
                showSetup();
                return;
            }

            // OAuth 2.0 User-Agent Flow (Token Flow)
            const authUrl = `${loginUrl}/services/oauth2/authorize?` +
                `response_type=token&` +
                `client_id=${encodeURIComponent(clientId)}&` +
                `redirect_uri=${encodeURIComponent(redirectUri)}`;

            window.location.href = authUrl;
        }

        function handleOAuthCallback() {
            const hash = window.location.hash.substring(1);
            const params = new URLSearchParams(hash);

            const accessToken = params.get('access_token');
            const instanceUrl = params.get('instance_url');

            if (accessToken && instanceUrl) {
                // Save tokens
                localStorage.setItem(STORAGE_KEYS.ACCESS_TOKEN, accessToken);
                localStorage.setItem(STORAGE_KEYS.INSTANCE_URL, instanceUrl);

                // Clear the hash from URL
                window.history.replaceState(null, null, window.location.pathname);

                // Fetch user info
                fetchUserInfo(accessToken, instanceUrl);
            } else if (params.get('error')) {
                showError('OAuth Error: ' + params.get('error_description'));
                showLoginSection();
            }
        }

        async function fetchUserInfo(accessToken, instanceUrl) {
            try {
                const response = await fetch(`${instanceUrl}/services/oauth2/userinfo`, {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });

                if (response.ok) {
                    const userInfo = await response.json();
                    localStorage.setItem(STORAGE_KEYS.USER_INFO, JSON.stringify(userInfo));
                    showSuccess('Successfully connected to Salesforce!');
                    showUserInfo();
                    // Note: loadScorecard() is called by loadOpportunityOwners() after auto-selecting first owner
                } else {
                    throw new Error('Failed to fetch user info');
                }
            } catch (error) {
                console.error('Error fetching user info:', error);
                // Silently continue - user info is not critical for the app to function
                showUserInfo();
                // Note: loadScorecard() is called by loadOpportunityOwners() after auto-selecting first owner
            }
        }

        function logout() {
            localStorage.removeItem(STORAGE_KEYS.ACCESS_TOKEN);
            localStorage.removeItem(STORAGE_KEYS.INSTANCE_URL);
            localStorage.removeItem(STORAGE_KEYS.USER_INFO);

            // Clear any displayed messages first
            document.getElementById('errorMessage').classList.add('hidden');
            document.getElementById('successMessage').classList.add('hidden');

            showLoginSection();

            // Show success message after a brief delay to ensure UI is ready
            setTimeout(() => {
                showSuccess('Logged out successfully');
            }, 100);
        }

        // ==========================================
        // UI HELPERS
        // ==========================================
        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.classList.remove('hidden');
            setTimeout(() => errorDiv.classList.add('hidden'), 8000);
        }

        function showSuccess(message) {
            const successDiv = document.getElementById('successMessage');
            successDiv.textContent = message;
            successDiv.classList.remove('hidden');
            setTimeout(() => successDiv.classList.add('hidden'), 3000);
        }

        function showEditTargets() {
            // Hide scorecard section
            document.getElementById('scorecardSection').classList.add('hidden');

            // Show edit targets section
            const editSection = document.getElementById('editTargetsSection');
            editSection.classList.remove('hidden');

            const inputsContainer = document.getElementById('targetInputs');

            // Clear existing inputs
            inputsContainer.innerHTML = '';

            // Get current configs with saved or default targets
            const configs = getMetricConfigs();

            // Separate by type for organized display
            const reportMetrics = configs.filter(c => c.type === 'report');
            const calculatedMetrics = configs.filter(c => c.type === 'calculated');

            // Report-based metrics section
            if (reportMetrics.length > 0) {
                const header = document.createElement('h3');
                header.style.cssText = 'margin: 20px 0 10px 0; color: #555; font-size: 16px;';
                header.textContent = 'Report-Based Metrics';
                inputsContainer.appendChild(header);

                reportMetrics.forEach(config => {
                    const inputGroup = document.createElement('div');
                    inputGroup.className = 'target-input-group';
                    const unitPrefix = config.unit === '$' ? '$' : '';
                    const unitSuffix = config.unit === '%' ? '%' : '';
                    const hasUnit = unitPrefix || unitSuffix;

                    if (hasUnit) {
                        inputGroup.innerHTML = `
                            <label for="target_${config.metricId}">${config.metricName}</label>
                            <div class="input-with-unit">
                                ${unitPrefix ? `<span class="input-unit input-unit-prefix">${unitPrefix}</span>` : ''}
                                <input
                                    type="number"
                                    id="target_${config.metricId}"
                                    value="${config.target}"
                                    min="0"
                                    step="${config.unit === '%' ? '0.1' : '1'}"
                                    placeholder="Enter target"
                                />
                                ${unitSuffix ? `<span class="input-unit input-unit-suffix">${unitSuffix}</span>` : ''}
                            </div>
                        `;
                    } else {
                        inputGroup.innerHTML = `
                            <label for="target_${config.metricId}">${config.metricName}</label>
                            <input
                                type="number"
                                id="target_${config.metricId}"
                                value="${config.target}"
                                min="0"
                                step="1"
                                placeholder="Enter target"
                            />
                        `;
                    }
                    inputsContainer.appendChild(inputGroup);
                });
            }

            // Calculated metrics section
            if (calculatedMetrics.length > 0) {
                const header = document.createElement('h3');
                header.style.cssText = 'margin: 30px 0 10px 0; color: #555; font-size: 16px;';
                header.textContent = 'Calculated Metrics';
                inputsContainer.appendChild(header);

                calculatedMetrics.forEach(config => {
                    const inputGroup = document.createElement('div');
                    inputGroup.className = 'target-input-group';
                    const unitPrefix = config.unit === '$' ? '$' : '';
                    const unitSuffix = config.unit === '%' ? '%' : '';
                    const hasUnit = unitPrefix || unitSuffix;

                    if (hasUnit) {
                        inputGroup.innerHTML = `
                            <label for="target_${config.metricId}">${config.metricName}</label>
                            <div class="input-with-unit">
                                ${unitPrefix ? `<span class="input-unit input-unit-prefix">${unitPrefix}</span>` : ''}
                                <input
                                    type="number"
                                    id="target_${config.metricId}"
                                    value="${config.target}"
                                    min="0"
                                    step="${config.unit === '%' ? '0.1' : '1'}"
                                    placeholder="Enter target"
                                />
                                ${unitSuffix ? `<span class="input-unit input-unit-suffix">${unitSuffix}</span>` : ''}
                            </div>
                        `;
                    } else {
                        inputGroup.innerHTML = `
                            <label for="target_${config.metricId}">${config.metricName}</label>
                            <input
                                type="number"
                                id="target_${config.metricId}"
                                value="${config.target}"
                                min="0"
                                step="1"
                                placeholder="Enter target"
                            />
                        `;
                    }
                    inputsContainer.appendChild(inputGroup);
                });
            }
        }

        function showScorecard() {
            // Hide edit sections
            document.getElementById('editTargetsSection').classList.add('hidden');
            document.getElementById('editAcceleratorSection').classList.add('hidden');

            // Show scorecard section
            document.getElementById('scorecardSection').classList.remove('hidden');
        }

        function saveTargets() {
            const configs = getMetricConfigs();
            const newTargets = {};

            // Collect new target values from inputs
            configs.forEach(config => {
                const input = document.getElementById(`target_${config.metricId}`);
                if (input) {
                    const value = parseFloat(input.value);
                    if (!isNaN(value) && value >= 0) {
                        newTargets[config.metricId] = value;
                    } else {
                        newTargets[config.metricId] = config.target; // Keep existing if invalid
                    }
                }
            });

            // Save to localStorage
            saveTargetsToStorage(newTargets);

            // Show success message
            showSuccess('Targets updated successfully!');

            // Go back to scorecard
            showScorecard();

            // Reload scorecard with new targets
            loadScorecard();
        }

        // ==========================================
        // SALESFORCE API CALLS
        // ==========================================
        async function fetchOpportunityOwners() {
            const accessToken = localStorage.getItem(STORAGE_KEYS.ACCESS_TOKEN);
            const instanceUrl = localStorage.getItem(STORAGE_KEYS.INSTANCE_URL);

            // Filter to only users whose role contains "VC AEs"
            const query = "SELECT Id, Name, UserRole.Name FROM User WHERE Id IN (SELECT OwnerId FROM Opportunity) AND UserRole.Name LIKE '%VC AEs%' ORDER BY Name";
            const url = `${instanceUrl}/services/data/v59.0/query?q=${encodeURIComponent(query)}`;

            try {
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    console.log('Filtered owners by role containing "VC AEs":', data.records.length, 'users found');
                    return data.records;
                } else {
                    console.error('Failed to fetch owners');
                    return [];
                }
            } catch (error) {
                console.error('Error fetching owners:', error);
                return [];
            }
        }

        async function loadOpportunityOwners() {
            const owners = await fetchOpportunityOwners();
            const select = document.getElementById('ownerSelect');

            select.innerHTML = '<option value="">All Owners</option>';

            owners.forEach(owner => {
                const option = document.createElement('option');
                option.value = owner.Name;  // Use name as value to match report data
                option.textContent = owner.Name;
                select.appendChild(option);
            });

            // Auto-select the first owner in the list
            if (owners.length > 0) {
                select.value = owners[0].Name;
                loadScorecard(); // Load metrics for the first owner
            }
        }

        async function fetchReportData(reportId, ownerId = null, includeDetails = true) {
            const accessToken = localStorage.getItem(STORAGE_KEYS.ACCESS_TOKEN);
            const instanceUrl = localStorage.getItem(STORAGE_KEYS.INSTANCE_URL);

            let url = `${instanceUrl}/services/data/v59.0/analytics/reports/${reportId}?includeDetails=${includeDetails}`;

            console.log('Fetching report:', reportId);
            console.log('Owner filter:', ownerId || 'None');
            console.log('Include details:', includeDetails);

            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json'
                }
            });

            console.log('Response status:', response.status);

            if (!response.ok) {
                const errorText = await response.text();
                console.error('Error response:', errorText);

                if (response.status === 401) {
                    // Token expired
                    logout();
                    throw new Error('Session expired. Please log in again.');
                }

                let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                try {
                    const errorJson = JSON.parse(errorText);
                    if (errorJson[0] && errorJson[0].message) {
                        errorMessage += ` - ${errorJson[0].message}`;
                    }
                } catch (e) {
                    errorMessage += ` - ${errorText}`;
                }

                throw new Error(errorMessage);
            }

            return await response.json();
        }

        // GP Attainment Report Configuration
        const GP_ATTAINMENT_REPORT_ID = '00OTP0000028AU52AM';

        // Fetch GP Attainment report with all groupings (uses POST to get full data)
        async function fetchGPAttainmentReport() {
            const accessToken = localStorage.getItem(STORAGE_KEYS.ACCESS_TOKEN);
            const instanceUrl = localStorage.getItem(STORAGE_KEYS.INSTANCE_URL);

            // Use POST with reportMetadata to get all groupings
            const url = `${instanceUrl}/services/data/v59.0/analytics/reports/${GP_ATTAINMENT_REPORT_ID}?includeDetails=false`;

            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    reportMetadata: {
                        // Request more groupings by setting a high standard date filter
                        reportFormat: 'SUMMARY'
                    }
                })
            });

            if (!response.ok) {
                throw new Error(`Failed to fetch GP Attainment report: ${response.status}`);
            }

            return await response.json();
        }

        async function loadGPAttainmentTable() {
            const section = document.getElementById('gpAttainmentSection');
            const content = document.getElementById('gpAttainmentContent');

            // Get selected owner from dropdown
            const ownerSelect = document.getElementById('ownerSelect');
            const selectedOwnerId = ownerSelect ? ownerSelect.value : null;

            try {
                const reportData = await fetchGPAttainmentReport();
                console.log('GP Attainment report data:', reportData);

                // Extract column information
                const columns = reportData.reportMetadata.detailColumns;
                const columnInfo = reportData.reportExtendedMetadata.detailColumnInfo;
                const groupingsDown = reportData.groupingsDown;

                console.log('Columns:', columns);
                console.log('Column Info:', columnInfo);
                console.log('Groupings:', groupingsDown);
                console.log('Selected owner filter:', selectedOwnerId || 'All');

                // Build table data from groupings (summary report grouped by Account Owner)
                const tableData = [];

                if (groupingsDown && groupingsDown.groupings) {
                    for (const grouping of groupingsDown.groupings) {
                        const ownerName = grouping.label;

                        // Filter by selected owner if one is selected (case-insensitive, trim whitespace)
                        if (selectedOwnerId) {
                            const normalizedOwner = ownerName.trim().toLowerCase();
                            const normalizedSelected = selectedOwnerId.trim().toLowerCase();
                            if (normalizedOwner !== normalizedSelected) {
                                continue;
                            }
                        }

                        const factKey = grouping.key + '!T';
                        const factData = reportData.factMap[factKey];

                        if (factData && factData.aggregates) {
                            const aggregates = factData.aggregates;
                            // Based on the report columns:
                            // Sum of Estimated GP Attainment, Sum of Q1 '26 Quota, Sum of Large Logos, Record Count, Percent to Quota
                            // The order depends on the report configuration

                            // Find the indices for each column we need
                            const aggLabels = reportData.reportMetadata.aggregates || [];
                            console.log('Aggregate labels for', ownerName, ':', aggLabels);
                            console.log('Aggregates:', aggregates);

                            // Use positional indexing based on report column order:
                            // 0: Sum of Estimated GP Attainment
                            // 1: Sum of Q1 '26 Quota
                            // 2: Sum of Large Logos
                            // 3: Record Count
                            const gpAttainment = aggregates[0]?.value || 0;
                            const quota = aggregates[1]?.value || 0;
                            const largeLogos = aggregates[2]?.value || 0;
                            // Calculate % To Quota from GP Attainment and Quota
                            const percentToQuota = quota > 0 ? (gpAttainment / quota) * 100 : 0;

                            console.log(`${ownerName}: GP=${gpAttainment}, Quota=${quota}, Large Logos=${largeLogos}, %=${percentToQuota.toFixed(2)}`);

                            tableData.push({
                                name: ownerName,
                                gpAttainment: gpAttainment,
                                quota: quota,
                                largeLogos: largeLogos,
                                percentToQuota: percentToQuota
                            });
                        }
                    }
                }

                // Sort by percent to quota descending
                tableData.sort((a, b) => b.percentToQuota - a.percentToQuota);

                // Get quarter progress for projections
                const quarterProgress = getQuarterProgress();
                const percentElapsed = quarterProgress.percentElapsed;

                // Calculate projections, payouts, and logo multipliers for each rep
                tableData.forEach(row => {
                    // Project to end of quarter: current / percentElapsed
                    row.projectedGP = percentElapsed > 0 ? row.gpAttainment / percentElapsed : 0;
                    row.projectedLargeLogos = percentElapsed > 0 ? row.largeLogos / percentElapsed : 0;
                    row.projectedPercentToQuota = row.quota > 0 ? (row.projectedGP / row.quota) * 100 : 0;
                    // Calculate payouts using accelerator
                    row.payout = calculatePayout(row.percentToQuota);
                    row.projectedPayout = calculatePayout(row.projectedPercentToQuota);
                    // Calculate large logo multipliers
                    row.logoMultiplier = calculateLargeLogoMultiplier(row.largeLogos);
                    row.projectedLogoMultiplier = calculateLargeLogoMultiplier(Math.round(row.projectedLargeLogos));
                });

                // Render current actuals table
                const currentTableHTML = `
                    <h4 style="color: #0A0A0A; margin-bottom: 12px; font-size: 18px; font-weight: 600;">Current Actuals</h4>
                    <table class="gp-attainment-table">
                        <thead>
                            <tr>
                                <th>Rep Name</th>
                                <th>Est. GP Attainment</th>
                                <th>Quota</th>
                                <th>% To Quota</th>
                                <th>Payout %</th>
                                <th>Large Logos</th>
                                <th>Large Logo<br>Multiplier</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableData.map(row => {
                                const percentClass = row.percentToQuota >= 100 ? 'percent-good' :
                                                     row.percentToQuota >= 50 ? 'percent-warning' : 'percent-danger';
                                const payoutClass = row.payout >= 120 ? 'percent-good' :
                                                    row.payout >= 50 ? 'percent-warning' : 'percent-danger';
                                const logoMultClass = row.logoMultiplier >= 1.0 ? 'percent-good' :
                                                      row.logoMultiplier >= 0.85 ? 'percent-warning' : 'percent-danger';
                                return `
                                    <tr>
                                        <td class="rep-name">${row.name}</td>
                                        <td class="currency">$${row.gpAttainment.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})}</td>
                                        <td class="currency">$${row.quota.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})}</td>
                                        <td class="${percentClass}">${Math.round(row.percentToQuota)}%</td>
                                        <td class="${payoutClass}">${Math.round(row.payout)}%</td>
                                        <td>${row.largeLogos}</td>
                                        <td class="${logoMultClass}">${row.logoMultiplier}x</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                `;

                // Sort by projected percent to quota for projections table
                const projectedData = [...tableData].sort((a, b) => b.projectedPercentToQuota - a.projectedPercentToQuota);

                // Render projected table
                const projectedTableHTML = `
                    <h4 style="color: #0A0A0A; margin: 24px 0 12px 0; font-size: 18px; font-weight: 600;">Projected End of Q${quarterProgress.quarter} (${Math.round(percentElapsed * 100)}% of Quarter Elapsed)</h4>
                    <table class="gp-attainment-table">
                        <thead>
                            <tr>
                                <th>Rep Name</th>
                                <th>Projected GP</th>
                                <th>Quota</th>
                                <th>Projected % To Quota</th>
                                <th>Projected Payout %</th>
                                <th>Projected Large Logos</th>
                                <th>Projected Logo<br>Multiplier</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${projectedData.map(row => {
                                const percentClass = row.projectedPercentToQuota >= 100 ? 'percent-good' :
                                                     row.projectedPercentToQuota >= 75 ? 'percent-warning' : 'percent-danger';
                                const payoutClass = row.projectedPayout >= 120 ? 'percent-good' :
                                                    row.projectedPayout >= 50 ? 'percent-warning' : 'percent-danger';
                                const logoMultClass = row.projectedLogoMultiplier >= 1.0 ? 'percent-good' :
                                                      row.projectedLogoMultiplier >= 0.85 ? 'percent-warning' : 'percent-danger';
                                return `
                                    <tr>
                                        <td class="rep-name">${row.name}</td>
                                        <td class="currency">$${Math.round(row.projectedGP).toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})}</td>
                                        <td class="currency">$${row.quota.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})}</td>
                                        <td class="${percentClass}">${Math.round(row.projectedPercentToQuota)}%</td>
                                        <td class="${payoutClass}">${Math.round(row.projectedPayout)}%</td>
                                        <td>${Math.round(row.projectedLargeLogos)}</td>
                                        <td class="${logoMultClass}">${row.projectedLogoMultiplier}x</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                `;

                content.innerHTML = currentTableHTML + projectedTableHTML;
                section.classList.remove('hidden');

            } catch (error) {
                console.error('Error loading GP Attainment table:', error);
                content.innerHTML = `<div class="gp-attainment-loading" style="color: #EF4444;">Error loading GP Attainment data: ${error.message}</div>`;
                section.classList.remove('hidden');
            }
        }

        function extractMetricValue(reportData, config, ownerId = null) {
            try {
                const factMap = reportData.factMap;

                // If no owner filter, use grand totals
                if (!ownerId) {
                    if (factMap && factMap['T!T']) {
                        const grandTotal = factMap['T!T'];
                        const aggregateValues = grandTotal.aggregates;

                        if (aggregateValues && aggregateValues.length > 0) {
                            if (config.aggregationType === 'formula') {
                                // For percentage fields, find the value that looks like a percentage (0-100 or 0-1)
                                console.log('All aggregate values:', aggregateValues.map(a => a.value));
                                for (let i = 0; i < aggregateValues.length; i++) {
                                    const val = parseFloat(aggregateValues[i]?.value);
                                    // Check if it's a percentage (0-100) or decimal (0-1)
                                    if (val >= 0 && val <= 100 && val !== Math.floor(val) || (val > 0 && val < 1)) {
                                        console.log(`Found percentage value at index ${i}:`, val);
                                        return val <= 1 ? val * 100 : val;
                                    }
                                }
                                // Fallback: use second-to-last if available (often the formula column)
                                const idx = aggregateValues.length >= 2 ? aggregateValues.length - 2 : 0;
                                const value = aggregateValues[idx]?.value;
                                console.log(`Fallback to index ${idx}:`, value);
                                return parseFloat(value) || 0;
                            }

                            if (config.aggregationType === 'formula_currency') {
                                // For currency formula fields, find by matching key in reportMetadata.aggregates
                                console.log('All aggregate values (currency):', aggregateValues.map(a => a.value));
                                const aggInfo = reportData.reportExtendedMetadata?.aggregateColumnInfo;
                                const aggOrder = reportData.reportMetadata?.aggregates || [];
                                console.log('Aggregate order from metadata:', aggOrder);

                                if (aggInfo && config.aggregationField) {
                                    // Find the key that matches our field
                                    const keys = Object.keys(aggInfo);
                                    let targetKey = null;
                                    for (const key of keys) {
                                        const info = aggInfo[key];
                                        if (info.label && info.label.toLowerCase().includes(config.aggregationField.toLowerCase())) {
                                            targetKey = key;
                                            console.log(`Found matching key: ${key} for "${config.aggregationField}"`);
                                            break;
                                        }
                                    }

                                    if (targetKey) {
                                        // Find position of this key in the aggregates order
                                        const idx = aggOrder.indexOf(targetKey);
                                        if (idx !== -1) {
                                            const value = aggregateValues[idx]?.value;
                                            console.log(`Found currency field at ordered index ${idx}:`, value);
                                            return parseFloat(value) || 0;
                                        }
                                    }
                                }
                                // Fallback: use last aggregate (rightmost column)
                                const lastIdx = aggregateValues.length - 1;
                                const value = aggregateValues[lastIdx]?.value;
                                console.log(`Currency fallback to last index ${lastIdx}:`, value);
                                return parseFloat(value) || 0;
                            }

                            if (config.aggregationType === 'sum' || config.aggregationType === 'average') {
                                const value = aggregateValues[0].value;
                                return parseFloat(value) || 0;
                            }

                            if (config.aggregationType === 'count') {
                                return parseInt(aggregateValues[0].value) || grandTotal.rowCount || 0;
                            }
                        }
                    }

                    if (config.aggregationType === 'count') {
                        const rowCount = Object.keys(factMap).filter(key => key.startsWith('0')).length;
                        return rowCount;
                    }

                    return 0;
                }

                // Filter by owner using groupings (for summary reports)
                console.log('Filtering by owner:', ownerId);

                // Get current month/year for filtering
                const now = new Date();
                const currentMonth = now.toLocaleString('en-US', { month: 'long', year: 'numeric' }); // e.g., "January 2026"
                console.log('Current month:', currentMonth);

                // Check if this is a summary report with groupings
                if (reportData.groupingsDown && reportData.groupingsDown.groupings) {
                    const topLevelGroupings = reportData.groupingsDown.groupings;
                    console.log('Found', topLevelGroupings.length, 'top-level groupings');

                    // Find the grouping that matches the owner name
                    for (let grouping of topLevelGroupings) {
                        console.log('Checking grouping:', grouping.label, 'vs', ownerId);
                        if (grouping.label === ownerId) {
                            // Found the matching owner grouping
                            const groupKey = grouping.key;
                            console.log('Found matching owner grouping with key:', groupKey);

                            // Check if there are sub-groupings (date groupings)
                            if (grouping.groupings && grouping.groupings.length > 0) {
                                console.log('Found', grouping.groupings.length, 'date sub-groupings');

                                // Find the sub-grouping that matches the current month
                                for (let dateGrouping of grouping.groupings) {
                                    console.log('Checking date grouping:', dateGrouping.label);

                                    // Check if this date grouping matches the current month
                                    if (dateGrouping.label === currentMonth) {
                                        const dateFactKey = dateGrouping.key + '!T';  // Add !T suffix for totals
                                        console.log('Found current month grouping with key:', dateFactKey);

                                        // Get the data for this specific month
                                        if (factMap && factMap[dateFactKey]) {
                                            const monthFact = factMap[dateFactKey];
                                            console.log('Month fact data:', monthFact);
                                            console.log('All aggregates:', monthFact.aggregates);

                                            if (monthFact.aggregates && monthFact.aggregates.length > 0) {
                                                let value;
                                                const lastIndex = monthFact.aggregates.length - 1;

                                                if (config.aggregationType === 'count') {
                                                    // Record count is typically the last aggregate
                                                    value = monthFact.aggregates[lastIndex].value;
                                                    console.log('Using last aggregate (record count):', value);
                                                    return parseInt(value) || 0;
                                                } else if (config.aggregationType === 'formula') {
                                                    // For percentage fields, find the value that looks like a percentage
                                                    console.log('All aggregate values:', monthFact.aggregates.map(a => a.value));
                                                    for (let i = 0; i < monthFact.aggregates.length; i++) {
                                                        const val = parseFloat(monthFact.aggregates[i]?.value);
                                                        if (val >= 0 && val <= 100 && val !== Math.floor(val) || (val > 0 && val < 1)) {
                                                            console.log(`Found percentage value at index ${i}:`, val);
                                                            return val <= 1 ? val * 100 : val;
                                                        }
                                                    }
                                                    // Fallback
                                                    const idx = monthFact.aggregates.length >= 2 ? monthFact.aggregates.length - 2 : 0;
                                                    value = monthFact.aggregates[idx]?.value;
                                                    console.log(`Fallback to index ${idx}:`, value);
                                                    return parseFloat(value) || 0;
                                                } else if (config.aggregationType === 'formula_currency') {
                                                    // For currency formula fields, find by matching key in reportMetadata.aggregates
                                                    console.log('All aggregate values (currency):', monthFact.aggregates.map(a => a.value));
                                                    const aggInfo = reportData.reportExtendedMetadata?.aggregateColumnInfo;
                                                    const aggOrder = reportData.reportMetadata?.aggregates || [];

                                                    if (aggInfo && config.aggregationField) {
                                                        const keys = Object.keys(aggInfo);
                                                        let targetKey = null;
                                                        for (const key of keys) {
                                                            const info = aggInfo[key];
                                                            if (info.label && info.label.toLowerCase().includes(config.aggregationField.toLowerCase())) {
                                                                targetKey = key;
                                                                break;
                                                            }
                                                        }
                                                        if (targetKey) {
                                                            const idx = aggOrder.indexOf(targetKey);
                                                            if (idx !== -1) {
                                                                value = monthFact.aggregates[idx]?.value;
                                                                console.log(`Found currency field at ordered index ${idx}:`, value);
                                                                return parseFloat(value) || 0;
                                                            }
                                                        }
                                                    }
                                                    value = monthFact.aggregates[lastIndex]?.value;
                                                    console.log(`Currency fallback to last index:`, value);
                                                    return parseFloat(value) || 0;
                                                } else {
                                                    value = monthFact.aggregates[0].value;
                                                    console.log('Using first aggregate:', value);
                                                    return parseFloat(value) || parseInt(value) || 0;
                                                }
                                            }
                                        } else {
                                            console.log('factMap[' + dateFactKey + '] not found');
                                        }
                                    }
                                }

                                console.log('No matching month grouping found for', currentMonth);
                                return 0;
                            } else {
                                // No date sub-groupings, use the owner total
                                const factKey = groupKey + '!T';
                                console.log('No date sub-groupings, using owner total:', factKey);

                                if (factMap && factMap[factKey]) {
                                    const ownerFact = factMap[factKey];
                                    console.log('Owner fact data:', ownerFact);

                                    if (ownerFact.aggregates && ownerFact.aggregates.length > 0) {
                                        let value;
                                        const lastIndex = ownerFact.aggregates.length - 1;

                                        if (config.aggregationType === 'count') {
                                            value = ownerFact.aggregates[lastIndex].value;
                                            console.log('Using last aggregate (record count):', value);
                                            return parseInt(value) || 0;
                                        } else if (config.aggregationType === 'formula') {
                                            // For percentage fields, find the value that looks like a percentage
                                            console.log('All aggregate values:', ownerFact.aggregates.map(a => a.value));
                                            for (let i = 0; i < ownerFact.aggregates.length; i++) {
                                                const val = parseFloat(ownerFact.aggregates[i]?.value);
                                                if (val >= 0 && val <= 100 && val !== Math.floor(val) || (val > 0 && val < 1)) {
                                                    console.log(`Found percentage value at index ${i}:`, val);
                                                    return val <= 1 ? val * 100 : val;
                                                }
                                            }
                                            // Fallback
                                            const idx = ownerFact.aggregates.length >= 2 ? ownerFact.aggregates.length - 2 : 0;
                                            value = ownerFact.aggregates[idx]?.value;
                                            console.log(`Fallback to index ${idx}:`, value);
                                            return parseFloat(value) || 0;
                                        } else if (config.aggregationType === 'formula_currency') {
                                            // For currency formula fields, find by matching key in reportMetadata.aggregates
                                            console.log('All aggregate values (currency):', ownerFact.aggregates.map(a => a.value));
                                            const aggInfo = reportData.reportExtendedMetadata?.aggregateColumnInfo;
                                            const aggOrder = reportData.reportMetadata?.aggregates || [];
                                            console.log('Aggregate order from metadata:', aggOrder);

                                            if (aggInfo && config.aggregationField) {
                                                const keys = Object.keys(aggInfo);
                                                let targetKey = null;
                                                for (const key of keys) {
                                                    const info = aggInfo[key];
                                                    if (info.label && info.label.toLowerCase().includes(config.aggregationField.toLowerCase())) {
                                                        targetKey = key;
                                                        console.log(`Found matching key: ${key} for "${config.aggregationField}"`);
                                                        break;
                                                    }
                                                }
                                                if (targetKey) {
                                                    const idx = aggOrder.indexOf(targetKey);
                                                    if (idx !== -1) {
                                                        value = ownerFact.aggregates[idx]?.value;
                                                        console.log(`Found currency field at ordered index ${idx}:`, value);
                                                        return parseFloat(value) || 0;
                                                    }
                                                }
                                            }
                                            value = ownerFact.aggregates[lastIndex]?.value;
                                            console.log(`Currency fallback to last index:`, value);
                                            return parseFloat(value) || 0;
                                        } else {
                                            value = ownerFact.aggregates[0].value;
                                            console.log('Using first aggregate:', value);
                                            return parseFloat(value) || parseInt(value) || 0;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    console.log('No matching owner grouping found');
                    return 0;
                }

                console.log('Report does not have groupingsDown structure');
                return 0;
            } catch (error) {
                console.error('Error extracting metric value:', error);
                return 0;
            }
        }

        function calculateStatus(actual, target) {
            const percentage = actual / target;
            if (percentage >= thresholds.success) return 'success';
            if (percentage >= thresholds.warning) return 'warning';
            return 'danger';
        }

        function formatNumber(num, unit) {
            if (unit === '$') {
                return '$' + Math.round(num).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
            }
            if (unit === '%') {
                return Math.round(num).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 }) + '%';
            }
            return Math.round(num).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
        }

        /**
         * Gets the current day of month and total days in current month
         * @returns {Object} {dayOfMonth, totalDays, percentElapsed, daysRemaining}
         */
        function getMonthProgress() {
            const now = new Date();
            const dayOfMonth = now.getDate();  // 1-31
            const year = now.getFullYear();
            const month = now.getMonth();

            // Get total days in current month
            const totalDays = new Date(year, month + 1, 0).getDate();

            // Calculate percent of month elapsed
            const percentElapsed = dayOfMonth / totalDays;

            return {
                dayOfMonth,
                totalDays,
                percentElapsed,
                daysRemaining: totalDays - dayOfMonth
            };
        }

        /**
         * Calculates progress through the current quarter
         * @returns {Object} Quarter progress data
         */
        function getQuarterProgress() {
            const now = new Date();
            const year = now.getFullYear();
            const month = now.getMonth(); // 0-11

            // Determine current quarter and its start/end months
            const quarter = Math.floor(month / 3) + 1; // 1-4
            const quarterStartMonth = (quarter - 1) * 3; // 0, 3, 6, or 9
            const quarterEndMonth = quarterStartMonth + 2; // 2, 5, 8, or 11

            // Get first day of quarter and last day of quarter
            const quarterStart = new Date(year, quarterStartMonth, 1);
            const quarterEnd = new Date(year, quarterEndMonth + 1, 0); // Last day of quarter

            // Calculate total days in quarter and days elapsed
            const totalDays = Math.ceil((quarterEnd - quarterStart) / (1000 * 60 * 60 * 24)) + 1;
            const daysElapsed = Math.floor((now - quarterStart) / (1000 * 60 * 60 * 24)) + 1;

            // Calculate percent elapsed
            const percentElapsed = Math.min(daysElapsed / totalDays, 1);

            return {
                quarter,
                year,
                daysElapsed,
                totalDays,
                percentElapsed,
                daysRemaining: totalDays - daysElapsed
            };
        }

        /**
         * Calculates pace-adjusted target based on days elapsed
         * @param {number} monthlyTarget - Full monthly target
         * @param {number} percentElapsed - Fraction of month elapsed (0-1)
         * @returns {number} Expected achievement by this point in month
         */
        function getPaceAdjustedTarget(monthlyTarget, percentElapsed) {
            return monthlyTarget * percentElapsed;
        }

        /**
         * Calculates if metric is on pace
         * @param {number} actual - Current actual value
         * @param {number} monthlyTarget - Full monthly target
         * @param {number} percentElapsed - Fraction of month elapsed (0-1)
         * @returns {string} 'success', 'warning', or 'danger'
         */
        function calculatePaceStatus(actual, monthlyTarget, percentElapsed) {
            const expectedByNow = getPaceAdjustedTarget(monthlyTarget, percentElapsed);

            // Handle edge case: if we're at the very start of the month
            if (expectedByNow === 0) {
                return 'success';  // Can't be behind if target is 0
            }

            const pacePercentage = actual / expectedByNow;

            // Using same thresholds as standard view (90%/70%)
            if (pacePercentage >= thresholds.success) return 'success';
            if (pacePercentage >= thresholds.warning) return 'warning';
            return 'danger';
        }

        /**
         * Projects end-of-month achievement based on current pace
         * @param {number} actual - Current actual value
         * @param {number} dayOfMonth - Current day of month
         * @param {number} totalDays - Total days in month
         * @returns {number} Projected final achievement
         */
        function getProjectedFinish(actual, dayOfMonth, totalDays) {
            if (dayOfMonth === 0) return 0;
            const dailyPace = actual / dayOfMonth;
            return dailyPace * totalDays;
        }

        /**
         * Calculates aggregate performance score across all metrics
         * @param {Array} metricsData - Array of {config, actual, status}
         * @param {string} viewMode - 'standard' or 'pace'
         * @returns {Object} {score, totalMetrics, percentage, status}
         */
        function calculateAggregateScore(metricsData, viewMode) {
            const monthProgress = getMonthProgress();
            let totalScore = 0;
            const totalMetrics = metricsData.length;

            metricsData.forEach(metric => {
                let metricScore = 0;

                if (viewMode === 'pace') {
                    // Pace-adjusted: actual Ã· expected-by-now
                    const expected = getPaceAdjustedTarget(metric.config.target, monthProgress.percentElapsed);
                    metricScore = expected > 0 ? metric.actual / expected : 0;
                } else {
                    // Standard: actual Ã· target
                    metricScore = metric.config.target > 0 ? metric.actual / metric.config.target : 0;
                }

                totalScore += metricScore;
            });

            // Calculate percentage: (totalScore / totalMetrics) * 100
            const percentage = (totalScore / totalMetrics) * 100;

            // Determine status based on percentage
            let status = 'danger';
            if (percentage >= 90) status = 'success';
            else if (percentage >= 70) status = 'warning';

            return {
                score: totalScore,
                totalMetrics: totalMetrics,
                percentage: percentage,
                status: status
            };
        }

        /**
         * Generates AI-powered insights and recommendations
         * @param {Array} metricsData - Array of {config, actual, status}
         * @param {string} ownerName - Name of the selected owner
         */
        function generateInsights(metricsData, ownerName) {
            const insightsSection = document.getElementById('insightsSection');
            const summaryDiv = document.getElementById('insightsSummary');
            const recommendationsDiv = document.getElementById('insightsRecommendations');

            // Recalculate metrics based on current view mode
            let processedMetrics = metricsData;
            const monthProgress = getMonthProgress();

            if (currentViewMode === 'pace') {
                processedMetrics = metricsData.map(metric => ({
                    ...metric,
                    status: calculatePaceStatus(metric.actual, metric.config.target, monthProgress.percentElapsed),
                    paceTarget: getPaceAdjustedTarget(metric.config.target, monthProgress.percentElapsed),
                    projected: getProjectedFinish(metric.actual, monthProgress.dayOfMonth, monthProgress.totalDays)
                }));
            }

            // Count metrics by status
            const statusCounts = {
                success: processedMetrics.filter(m => m.status === 'success').length,
                warning: processedMetrics.filter(m => m.status === 'warning').length,
                danger: processedMetrics.filter(m => m.status === 'danger').length
            };

            const totalMetrics = processedMetrics.length;
            const ownerText = ownerName ? ownerName : 'the team';
            const viewText = currentViewMode === 'pace' ? 'on pace for' : 'on track for';

            // Generate summary (adjust language for pace mode)
            let summaryText = '';
            if (statusCounts.success === totalMetrics) {
                summaryText = `<span class="recommendation-icon">â†’</span><span class="recommendation-text">Excellent performance! ${ownerText} is ${viewText} all ${totalMetrics} metrics.</span>`;
            } else if (statusCounts.success >= totalMetrics * 0.75) {
                summaryText = `<span class="recommendation-icon">â†’</span><span class="recommendation-text">Strong performance overall. ${ownerText} is ${viewText} ${statusCounts.success} out of ${totalMetrics} metrics.</span>`;
            } else if (statusCounts.danger >= totalMetrics * 0.5) {
                const pacePhrase = currentViewMode === 'pace' ? 'behind pace on' : 'behind target on';
                summaryText = `<span class="recommendation-icon">â†’</span><span class="recommendation-text">Performance needs attention. ${ownerText} is ${pacePhrase} ${statusCounts.danger} out of ${totalMetrics} metrics.</span>`;
            } else {
                summaryText = `<span class="recommendation-icon">â†’</span><span class="recommendation-text">Mixed performance. ${ownerText} is ${viewText} ${statusCounts.success} metrics, at risk for ${statusCounts.warning}, and behind on ${statusCounts.danger}.</span>`;
            }

            summaryDiv.innerHTML = summaryText;

            // Generate recommendations (adjust for pace mode)
            const recommendations = [];

            processedMetrics.forEach(metric => {
                if (currentViewMode === 'pace') {
                    // PACE MODE RECOMMENDATIONS
                    const percentage = metric.paceTarget > 0 ? (metric.actual / metric.paceTarget) * 100 : 100;
                    const dailyPaceNeeded = metric.config.target / monthProgress.totalDays;
                    const gap = metric.paceTarget - metric.actual;

                    if (metric.status === 'danger') {
                        if (metric.actual === 0) {
                            recommendations.push({
                                priority: 1,
                                text: `<strong>Urgent:</strong> ${metric.config.metricName} is at 0. Need to average ${formatNumber(dailyPaceNeeded, metric.config.unit)}/day to hit monthly target.`
                            });
                        } else {
                            recommendations.push({
                                priority: 1,
                                text: `<strong>Behind Pace:</strong> ${metric.config.metricName} needs ${formatNumber(gap, metric.config.unit)} more to be on pace. Projected finish: ${formatNumber(metric.projected, metric.config.unit)}.`
                            });
                        }
                    } else if (metric.status === 'warning') {
                        recommendations.push({
                            priority: 2,
                            text: `<strong>Slipping:</strong> ${metric.config.metricName} pace is slowing. Need ${formatNumber(gap, metric.config.unit)} more to stay on track.`
                        });
                    } else if (metric.projected > metric.config.target * 1.1) {
                        recommendations.push({
                            priority: 3,
                            text: `<strong>Ahead of pace:</strong> ${metric.config.metricName} is projected to finish at ${formatNumber(metric.projected, metric.config.unit)} - exceeding target!`
                        });
                    }
                } else {
                    // STANDARD MODE RECOMMENDATIONS (existing logic)
                    const percentage = (metric.actual / metric.config.target) * 100;

                    if (metric.status === 'danger') {
                        if (metric.actual === 0) {
                            recommendations.push({
                                priority: 1,
                                text: `<strong>Urgent:</strong> ${metric.config.metricName} is at 0. Immediate action required.`
                            });
                        } else {
                            const gap = metric.config.target - metric.actual;
                            recommendations.push({
                                priority: 1,
                                text: `<strong>Focus:</strong> ${metric.config.metricName} needs ${formatNumber(gap, metric.config.unit)} more to reach target. Currently at ${percentage.toFixed(0)}% of goal.`
                            });
                        }
                    } else if (metric.status === 'warning') {
                        const gap = metric.config.target - metric.actual;
                        recommendations.push({
                            priority: 2,
                            text: `<strong>Monitor:</strong> ${metric.config.metricName} is at risk. Push for ${formatNumber(gap, metric.config.unit)} more to get back on track.`
                        });
                    }
                }
            });

            // Find top performer
            const topPerformer = metricsData.reduce((best, current) => {
                const currentPct = (current.actual / current.config.target) * 100;
                const bestPct = (best.actual / best.config.target) * 100;
                return currentPct > bestPct ? current : best;
            });

            if (topPerformer && (topPerformer.actual / topPerformer.config.target) >= 1.2) {
                recommendations.push({
                    priority: 3,
                    text: `<strong>Great work:</strong> ${topPerformer.config.metricName} is performing exceptionally at ${((topPerformer.actual / topPerformer.config.target) * 100).toFixed(0)}% of target. Keep this momentum!`
                });
            }

            // Sort by priority (lower number = higher priority)
            recommendations.sort((a, b) => a.priority - b.priority);

            // Render recommendations
            if (recommendations.length > 0) {
                recommendationsDiv.innerHTML = `
                    <h4>Recommended Actions</h4>
                    ${recommendations.map(rec => `
                        <div class="recommendation-item">
                            <span class="recommendation-icon">â†’</span>
                            <span class="recommendation-text">${rec.text}</span>
                        </div>
                    `).join('')}
                `;
            } else {
                recommendationsDiv.innerHTML = `
                    <h4>Recommended Actions</h4>
                    <div class="recommendation-item">
                        <span class="recommendation-icon">âœ“</span>
                        <span class="recommendation-text"><strong>Maintain course:</strong> All metrics are performing well. Continue current strategies.</span>
                    </div>
                `;
            }

            // Show the insights section
            insightsSection.classList.remove('hidden');
        }

        /**
         * Creates an SVG circular gauge (speedometer style)
         * @param {number} percentage - Achievement percentage (0-100+)
         * @param {string} status - Status color: 'success', 'warning', or 'danger'
         * @returns {string} SVG markup for the circular gauge
         */
        function createCircularGauge(percentage, status) {
            // SVG dimensions
            const size = 200;
            const strokeWidth = 16;
            const center = size / 2;
            const radius = (size - strokeWidth) / 2;

            // Calculate the arc path for a semi-circle (180 degrees)
            // Start at 180Â° (9 o'clock), end at 360Â° (3 o'clock)
            const startAngle = 180;
            const endAngle = 360;
            const totalDegrees = endAngle - startAngle;

            // Clamp visual arc at 100% so it doesn't wrap around
            const visualPercentage = Math.min(percentage, 100);
            const progressDegrees = (visualPercentage / 100) * totalDegrees;

            // Convert angles to radians for calculation
            const startRad = (startAngle * Math.PI) / 180;
            const progressRad = (progressDegrees * Math.PI) / 180;

            // Calculate arc path coordinates
            const startX = center + radius * Math.cos(startRad);
            const startY = center + radius * Math.sin(startRad);
            const endX = center + radius * Math.cos(startRad + progressRad);
            const endY = center + radius * Math.sin(startRad + progressRad);

            // Determine if arc should be "large" (>180Â°)
            const largeArcFlag = progressDegrees > 180 ? 1 : 0;

            // Background track path (full semi-circle)
            const backgroundEndX = center + radius * Math.cos(startRad + (totalDegrees * Math.PI) / 180);
            const backgroundEndY = center + radius * Math.sin(startRad + (totalDegrees * Math.PI) / 180);

            // Color based on status
            const colors = {
                success: '#10b981',
                warning: '#F59E0B',
                danger: '#EF4444'
            };
            const progressColor = colors[status] || colors.success;

            return `
                <svg class="gauge-svg" viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg">
                    <!-- Background track (gray semi-circle) -->
                    <path
                        d="M ${startX} ${startY} A ${radius} ${radius} 0 1 1 ${backgroundEndX} ${backgroundEndY}"
                        fill="none"
                        stroke="#E5E7EB"
                        stroke-width="${strokeWidth}"
                        stroke-linecap="round"
                    />

                    <!-- Progress arc (colored) -->
                    ${progressDegrees > 0 ? `
                    <path
                        d="M ${startX} ${startY} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${endX} ${endY}"
                        fill="none"
                        stroke="${progressColor}"
                        stroke-width="${strokeWidth}"
                        stroke-linecap="round"
                    />
                    ` : ''}

                    <!-- Center percentage text -->
                    <text
                        x="${center}"
                        y="${center + 10}"
                        text-anchor="middle"
                        font-size="36"
                        font-weight="700"
                        fill="#0A0A0A"
                    >${percentage.toFixed(0)}%</text>

                    <!-- Achievement label -->
                    <text
                        x="${center}"
                        y="${center + 35}"
                        text-anchor="middle"
                        font-size="12"
                        font-weight="600"
                        fill="#666"
                        letter-spacing="0.5"
                    >ACHIEVEMENT</text>
                </svg>
            `;
        }

        function createMetricCard(config, actual, error = null) {
            let percentage, status, displayTarget, statusLabel;
            const monthProgress = getMonthProgress();

            if (currentViewMode === 'pace') {
                // PACE-ADJUSTED VIEW
                const paceTarget = getPaceAdjustedTarget(config.target, monthProgress.percentElapsed);
                const projected = getProjectedFinish(actual, monthProgress.dayOfMonth, monthProgress.totalDays);

                percentage = paceTarget > 0 ? (actual / paceTarget) * 100 : 100;
                status = calculatePaceStatus(actual, config.target, monthProgress.percentElapsed);
                displayTarget = paceTarget;
                statusLabel = status === 'success' ? 'âœ“ On Pace' : status === 'warning' ? 'âš  Below Pace' : 'âœ— Off Pace';

            } else {
                // STANDARD VIEW
                percentage = (actual / config.target) * 100;
                status = calculateStatus(actual, config.target);
                displayTarget = config.target;
                statusLabel = status === 'success' ? 'âœ“ On Track' : status === 'warning' ? 'âš  At Risk' : 'âœ— Behind';
            }

            const gaugeHTML = createCircularGauge(percentage, status);

            // Determine subtitle based on metric type and ID
            let reportLink;
            if (config.type === 'report') {
                reportLink = `<a href="https://rho.lightning.force.com/${config.reportId}" target="_blank" style="font-size: 14px; color: #00EBC0; text-decoration: none; display: block; margin-top: 4px;">View Report</a>`;
            } else {
                reportLink = `<div style="font-size: 14px; color: #999; margin-top: 4px;">Calculated Metric</div>`;
            }

            // Build metric values HTML based on view mode
            let valuesHTML;
            if (currentViewMode === 'pace') {
                const projected = getProjectedFinish(actual, monthProgress.dayOfMonth, monthProgress.totalDays);
                valuesHTML = `
                    <div class="value-item">
                        <div class="value-label">Current</div>
                        <div class="value-number">${formatNumber(actual, config.unit)}</div>
                    </div>
                    <div class="value-item">
                        <div class="value-label">Expected</div>
                        <div class="value-number">${formatNumber(displayTarget, config.unit)}</div>
                    </div>
                    <div class="value-item">
                        <div class="value-label">Projected</div>
                        <div class="value-number">${formatNumber(projected, config.unit)}</div>
                    </div>
                `;
            } else {
                valuesHTML = `
                    <div class="value-item">
                        <div class="value-label">Current</div>
                        <div class="value-number">${formatNumber(actual, config.unit)}</div>
                    </div>
                    <div class="value-item">
                        <div class="value-label">Target</div>
                        <div class="value-number">${formatNumber(displayTarget, config.unit)}</div>
                    </div>
                `;
            }

            return `
                <div class="metric-card">
                    <div class="metric-header">
                        <div>
                            <div class="metric-name">${config.metricName}</div>
                            ${reportLink}
                        </div>
                    </div>

                    <div class="gauge-container">
                        ${gaugeHTML}
                    </div>

                    <div class="metric-values">
                        ${valuesHTML}
                    </div>
                </div>
            `;
        }

        /**
         * Creates the aggregate performance score card HTML
         * @param {Object} aggregateData - {score, totalMetrics, percentage, status}
         * @param {string} viewMode - 'standard' or 'pace'
         * @returns {string} HTML markup for aggregate card
         */
        function createAggregateCard(aggregateData, viewMode) {
            const { score, totalMetrics, percentage, status } = aggregateData;

            // Determine status label based on view mode
            const statusLabel = viewMode === 'pace'
                ? (status === 'success' ? 'âœ“ On Pace' : status === 'warning' ? 'âš  Below Pace' : 'âœ— Off Pace')
                : (status === 'success' ? 'âœ“ On Track' : status === 'warning' ? 'âš  At Risk' : 'âœ— Behind');

            // Create gauge
            const gaugeHTML = createCircularGauge(percentage, status);

            // Format score display
            const scoreDisplay = `${score.toFixed(1)} / ${totalMetrics}`;

            return `
                <div class="metric-card aggregate">
                    <div class="metric-header">
                        <div>
                            <div class="metric-name">Aggregate Score</div>
                            <div style="font-size: 16px; color: #999; margin-top: 4px;">Combined Performance Across All Metrics</div>
                        </div>
                    </div>

                    <div class="gauge-container aggregate-gauge">
                        ${gaugeHTML}
                    </div>

                    <div class="metric-values">
                        <div class="value-item">
                            <div class="value-label">Score</div>
                            <div class="value-number">${scoreDisplay}</div>
                        </div>
                        <div class="value-item">
                            <div class="value-label">Percentage</div>
                            <div class="value-number">${Math.round(percentage)}%</div>
                        </div>
                    </div>
                </div>
            `;
        }

        async function loadScorecard() {
            const accessToken = localStorage.getItem(STORAGE_KEYS.ACCESS_TOKEN);
            if (!accessToken) {
                showError('Not authenticated. Please log in.');
                showLoginSection();
                return;
            }

            document.getElementById('loading').classList.remove('hidden');

            // Load GP Attainment table in parallel with other data
            loadGPAttainmentTable();

            try {
                const scorecardDiv = document.getElementById('scorecard');
                scorecardDiv.innerHTML = '';

                // Get selected owner from dropdown
                const ownerSelect = document.getElementById('ownerSelect');
                const selectedOwnerId = ownerSelect ? ownerSelect.value : null;

                // Get all configs with current targets from localStorage
                const allConfigs = getMetricConfigs();

                // Filter to get only report-based metrics
                const reportConfigs = allConfigs.filter(c => c.type === 'report');
                const calculatedConfigs = allConfigs.filter(c => c.type === 'calculated');

                console.log('Loading scorecard with:', {
                    reportMetrics: reportConfigs.length,
                    calculatedMetrics: calculatedConfigs.length,
                    selectedOwner: selectedOwnerId || 'All Owners'
                });

                // Fetch all reports in parallel
                const reportMetrics = await Promise.all(
                    reportConfigs.map(async (config) => {
                        try {
                            const includeDetails = config.includeDetails !== false; // default true
                            const reportData = await fetchReportData(config.reportId, selectedOwnerId, includeDetails);
                            const actualValue = extractMetricValue(reportData, config, selectedOwnerId);
                            return { config, actualValue };
                        } catch (error) {
                            console.error(`Error loading report ${config.reportId}:`, error);
                            return { config, actualValue: 0, error: error.message };
                        }
                    })
                );

                // Build metricValues map from report results
                const metricValues = {};
                reportMetrics.forEach(({ config, actualValue, error }) => {
                    if (!error) {
                        metricValues[config.metricId] = actualValue;
                    }
                });

                console.log('Report metric values:', metricValues);

                // Calculate derived metrics
                const calculatedValues = calculateDerivedMetrics(metricValues, calculatedConfigs);
                console.log('Calculated metric values:', calculatedValues);

                // Combine all values
                Object.assign(metricValues, calculatedValues);

                // Collect metrics data for insights and aggregate
                const metricsForInsights = [];

                // First pass: collect all metric data
                allConfigs.forEach(config => {
                    const value = metricValues[config.metricId];
                    const hasError = typeof value === 'object' && value.error;
                    const actualValue = hasError ? 0 : value;
                    const reportError = reportMetrics.find(m => m.config.metricId === config.metricId && m.error);
                    const finalError = reportError ? reportError.error : null;

                    if (!finalError) {
                        const status = calculateStatus(actualValue, config.target);
                        metricsForInsights.push({
                            config: config,
                            actual: actualValue,
                            status: status
                        });
                    }
                });

                // Calculate and render aggregate card FIRST (if we have metrics)
                if (metricsForInsights.length > 0) {
                    const aggregateData = calculateAggregateScore(metricsForInsights, currentViewMode);
                    scorecardDiv.innerHTML = createAggregateCard(aggregateData, currentViewMode);
                }

                // Second pass: render individual metric cards
                allConfigs.forEach(config => {
                    const value = metricValues[config.metricId];
                    const hasError = typeof value === 'object' && value.error;
                    const error = hasError ? value.error : null;
                    const actualValue = hasError ? 0 : value;
                    const reportError = reportMetrics.find(m => m.config.metricId === config.metricId && m.error);
                    const finalError = reportError ? reportError.error : error;

                    if (finalError) {
                        scorecardDiv.innerHTML += `
                            <div class="metric-card">
                                <div class="metric-name">${config.metricName}</div>
                                <div style="color: #dc2626; margin-top: 10px;">Error: ${finalError}</div>
                                ${config.type === 'calculated' ? '<div style="color: #999; margin-top: 5px; font-size: 12px;">Check formula dependencies</div>' : ''}
                            </div>
                        `;
                    } else {
                        scorecardDiv.innerHTML += createMetricCard(config, actualValue, finalError);
                    }
                });

                // Generate AI insights
                if (metricsForInsights.length > 0) {
                    generateInsights(metricsForInsights, selectedOwnerId);
                }

            } catch (error) {
                console.error('Error loading scorecard:', error);
                showError('Failed to load scorecard: ' + error.message);
            } finally {
                document.getElementById('loading').classList.add('hidden');
            }
        }
    </script>
</body>
</html>
